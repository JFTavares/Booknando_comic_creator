Index: BooknandoFXL.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python\n# coding: utf-8\n# Create by: José Fernando Tavares - Booknando Livros\n# Twitter: @JFTavares\n# email: fernando@booknando.com.br\n# Booknando Comic Creator v0.2. \n# Just need Python v3\n# TO-DO: \n#   - Renomear imagens\n#   - Ler metadados das imagens\n#   - Leitura, recorte e importação de PDF\n#   - Manipular inDesign\n\n\nfrom io import open\nfrom textwrap import dedent\nfrom io import BytesIO\nimport zipfile\nimport uuid\nimport datetime\nimport random\nimport string\nimport argparse\nimport yaml\nimport csv\nimport optimiza\n\n\nclass Flx_maker(object):\n    version = 2  # class version when used as library\n\n    def __init__(self, file_name=None, meta_file=None, toc_file=None, verbose=0):\n\n        self._output_name = file_name\n        self.toc_file = toc_file\n        self._files = None\n        self._zip = None  # the in memory zip file\n        self._zip_data = None\n        self._content = []\n        self._count = 1\n        self._open_metadata(meta_file)\n        self.meta_info = dict(\n            title=metadata['title'],\n            creator=metadata['author'],\n            publisher=metadata['publisher'],\n            illustrator=metadata['illustrator'],\n            translator=metadata['translator'],\n            rights=metadata['rights'],\n            source=metadata['source'],\n            ibooksVersion=metadata['ibooksVersion'],\n            img_width=metadata['img_width'],\n            img_height=metadata['img_height'],\n            opf_name=\"content.opf\",\n            nav_name=\"nav.xhtml\",\n            dctime=datetime.datetime.utcnow().strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n            opf_ns='http://www.idpf.org/2007/opf',\n            xsi_ns='http://www.w3.org/2001/XMLSchema-instance',\n            dcterms_ns='http://purl.org/dc/terms/',\n            dc_ns='http://purl.org/dc/elements/1.1/',\n            rendition='http://www.idpf.org/vocab/rendition/#',\n            ibooks='http://vocabulary.itunes.apple.com/rdf/ibooks/vocabulary-extensions-1.0/',\n            cont_urn='urn:oasis:names:tc:opendocument:xmlns:container',\n            mt='application/oebps-package+xml',  # media-type\n            style_sheet='design.css',\n            alt=metadata['alt'],\n            uuid=None,\n            isbn=metadata['ISBN'],\n            nav_point=None,\n            nav_uuid=None,\n        )\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, typ, value, traceback):\n        if value is None:\n            if isinstance(self._zip_data, str):\n                return\n            self._write_content()\n            self._write_style_sheet()\n            self._write_nav()\n            self._zip.close()\n            self._zip = None\n            self.meta_info['nav_point'] = None\n            with open(self._output_name, 'wb') as ofp:\n                ofp.write(self._zip_data.getvalue())\n\n            return True\n        return False\n\n    def _open_metadata(self, meta_file):\n        with open(meta_file) as f:\n            global metadata\n            metadata = yaml.safe_load(f)\n\n    def add_image_file(self, file_name):\n        self._add_image_file(file_name)\n        self._count += 1\n\n    def _write_content(self):\n        d = self.meta_info.copy()\n        manifest = []\n        spine = []\n        d['manifest'] = ''\n        d['spine'] = ''\n        for f in self._content:\n            if f[1].startswith('html'):\n                manifest.append(\n                    '<item href=\"{}\" id=\"{}\" media-type=\"{}\"/>'.format(*f))\n            if f[1].startswith('img'):\n                manifest.append(\n                    '<item href=\"Images/{}\" id=\"{}\" media-type=\"{}\"/>'.format(*f))\n\n            if f[1].startswith('html'):\n                if int(f[3]) % 2:\n                    spine.append('<itemref idref=\"{}\" properties=\"page-spread-right\" />'.format(f[1]))\n                else:\n                    spine.append('<itemref idref=\"{}\" properties=\"page-spread-left\" />'.format(f[1]))\n\n        d['manifest'] = '\\n    '.join(manifest)\n        d['spine'] = '\\n    '.join(spine)\n        d['ts'] = datetime.datetime.utcnow().isoformat() + '+00:00'\n        self._write_file_from_template('OEBPS/' + self.meta_info[\"opf_name\"], 'template/content.tmpl', d)\n\n    def _read_create_toc(self, d):\n        lista_toc = []\n        nav = []\n        d['nav'] = ''\n        with open(self.toc_file, newline='') as csvfile:\n            spamreader = csv.reader(csvfile, delimiter=',')\n\n            for linha in spamreader:\n                lista_toc.append(linha)\n\n            for f in lista_toc:\n                nav.append('<li><a href=\"pag_{}.xhtml\">{}</a></li>'.format(f[1], f[0]))\n                d['nav'] = '\\n    '.join(nav)\n\n    def _create_page_list(self, d):\n        page_list = []\n        d['page_list'] = ''\n        for f in self._content:\n            if f[1].startswith('html'):\n                page_list.append('<li><a href=\"{}\">{}</a></li>'.format(f[0], f[3]))\n                d['page_list'] = '\\n    '.join(page_list)\n\n    def _write_nav(self):\n        d = self.meta_info.copy()\n        self._read_create_toc(d)\n        self._create_page_list(d)\n        self._write_file_from_template('OEBPS/' + self.meta_info[\"nav_name\"], 'template/nav.tmpl', d)\n\n    def _add_html(self, title):\n        file_name = self._name(False)\n        d = self.meta_info.copy()\n        d['img_name'] = self._name()\n        self._write_file_from_template('OEBPS/' + file_name, 'template/html.tmpl', d)\n        self._content.append(\n            (file_name, 'html{}'.format(self._count), 'application/xhtml+xml', '{}'.format(self._count)))\n\n    # Função para gravar arquivo usando um template\n    def _write_file_from_template(self, file, template, data):\n        template_file = open(template)\n        template = template_file.read()\n        self._add_from_bytes(file, template.format(**data).encode('utf-8'))\n\n    def _write_style_sheet(self):\n        file_name = self.meta_info['style_sheet']\n        self._write_file_from_template('OEBPS/Styles/' + file_name, 'template/css.tmpl', self.meta_info)\n        self._content.append((file_name, 'css', 'text/css'))\n\n    def _name(self, image=True):\n        return 'pag_{}.{}'.format(self._count, 'jpg' if image else 'xhtml')\n\n    def _add_image_file(self, file_name, z=None):\n        z = z if z else self.zip  # initializes if not done yet\n        self._add_html(file_name)\n\n        z.write(file_name, 'OEBPS/Images/' + self._name())\n        self._content.append((self._name(), 'img{}'.format(self._count), 'image/jpeg'))\n\n    @property\n    def zip(self):\n        if self._zip is not None:\n            return self._zip\n        self._zip_data = BytesIO()\n        # create zip with default compression\n        # self._zip_data = '/var/tmp/epubtmp/yy.zip'\n        self._zip = zipfile.ZipFile(self._zip_data, \"a\",\n                                    zipfile.ZIP_DEFLATED, False)\n        self.meta_info['uuid'] = uuid.uuid4()\n        self.meta_info['lead_ltr'] = random.choice(string.ascii_lowercase)\n        self.meta_info['nav_uuid'] = uuid.uuid4()\n        self._add_mimetype()\n        self._add_container()\n        return self._zip\n\n    def _add_from_bytes(self, file_name, data, no_compression=False):\n        self._zip.writestr(\n            file_name, data,\n            compress_type=zipfile.ZIP_STORED if no_compression else None)\n\n    def _add_mimetype(self):\n        self._add_from_bytes('mimetype', dedent(\"\"\"\\\n        application/epub+zip\n        \"\"\").rstrip(), no_compression=True)\n\n    def _add_container(self):\n        self._write_file_from_template('META-INF/container.xml', 'template/container.tmpl', self.meta_info)\n\n\ndef make_epub(args):\n    with Flx_maker(\n            file_name=args.output, meta_file=args.meta, toc_file=args.toc, verbose=0) as single_file_item:\n        for file_name in args.file_names.sort():\n            optimiza.resize_image(file_name)\n            single_file_item.add_image_file(file_name)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Gerador de Comic Books no formato ePub3 FLX')\n    parser.add_argument(\"--output\", \"-o\", help=\"Nome do arquivo\", required=True)\n    parser.add_argument(\"--meta\", help=\"Arquivo de metadados\", required=True)\n    parser.add_argument(\"--toc\", help=\"Arquivo de sumário\", required=True)\n    parser.add_argument(\"file_names\", nargs=\"+\")\n    args = parser.parse_args()\n\n    make_epub(args)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- BooknandoFXL.py	(revision c2fc523af8d327c1283ddfa6aa5c716df2584339)
+++ BooknandoFXL.py	(date 1598031062894)
@@ -93,6 +93,11 @@
             global metadata
             metadata = yaml.safe_load(f)
 
+    def open_toc(self, meta_file):
+        with open(meta_file) as f:
+            global metadata
+            metadata = yaml.safe_load(f)
+
     def add_image_file(self, file_name):
         self._add_image_file(file_name)
         self._count += 1
@@ -211,7 +216,8 @@
 
 def make_epub(args):
     with Flx_maker(
-            file_name=args.output, meta_file=args.meta, toc_file=args.toc, verbose=0) as single_file_item:
+            #file_name=args.output, meta_file=args.meta, toc_file=args.toc, verbose=0) as single_file_item:
+            file_name = args.output, meta_file = args.meta, verbose = 0) as single_file_item:
         for file_name in args.file_names.sort():
             optimiza.resize_image(file_name)
             single_file_item.add_image_file(file_name)
@@ -221,7 +227,7 @@
     parser = argparse.ArgumentParser(description='Gerador de Comic Books no formato ePub3 FLX')
     parser.add_argument("--output", "-o", help="Nome do arquivo", required=True)
     parser.add_argument("--meta", help="Arquivo de metadados", required=True)
-    parser.add_argument("--toc", help="Arquivo de sumário", required=True)
+    # parser.add_argument("--toc", help="Arquivo de sumário", required=True)
     parser.add_argument("file_names", nargs="+")
     args = parser.parse_args()
 
